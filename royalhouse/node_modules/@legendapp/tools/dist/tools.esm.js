import React, { memo, forwardRef, createElement, Component, useRef, useReducer, useState, useCallback, useEffect, useLayoutEffect } from 'react';

var animationFrames = {};
function hasAnimationFrameOnce(name) {
  return !!animationFrames[name];
}
function animationFrameOnce(name, cb) {
  var t = animationFrames[name];

  if (t) {
    cancelAnimationFrame(t);
  }

  animationFrames[name] = requestAnimationFrame(function () {
    delete animationFrames[name];
    cb();
  });
}
function clearAnimationFrameOnce(name) {
  var t = animationFrames[name];

  if (t) {
    cancelAnimationFrame(t);
    delete animationFrames[name];
  }
}

function arrayRemove(array, value) {
  var index = array.indexOf(value);

  if (index >= 0) {
    array.splice(index, 1);
  }

  return index;
}
function arrayRemoveAt(array, index) {
  return array.splice(index, 1)[0];
} // Binary search to find insertion index

function arrayFindInsertIndex(array, ele, comp) {
  var low = 0;
  var high = array.length - 1;

  while (low <= high) {
    var i = low + high >> 1;
    var c = comp(array[i], ele);

    if (c < 0) {
      low = i + 1;
    } else if (c > 0) {
      high = i - 1;
    } else {
      return i;
    }
  }

  return low;
}

function arrayInsertSorted(array, ele, comp) {
  var idx = arrayFindInsertIndex(array, ele, comp);
  array.splice(idx, 0, ele);
  return idx;
}

function isArray(obj) {
  return Array.isArray(obj);
}
function isString(obj) {
  return typeof obj === 'string';
}
function isObject(obj) {
  return typeof obj === 'object' && obj !== null && !isArray(obj);
}
function isNumber(obj) {
  return typeof obj === 'number' && !isNaN(obj);
}
function isBoolean(obj) {
  return obj === true || obj === false;
}
function isFunction(obj) {
  return typeof obj === 'function';
}

function _inheritsLoose(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;

  _setPrototypeOf(subClass, superClass);
}

function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };

  return _setPrototypeOf(o, p);
}

var _config = {};
function ConfigureMemoFnComponent(config) {
  _config = config || {};
}

var ErrorBoundary = /*#__PURE__*/function (_Component) {
  _inheritsLoose(ErrorBoundary, _Component);

  function ErrorBoundary(props) {
    var _this;

    _this = _Component.call(this, props) || this;
    _this.state = {
      error: null
    };
    return _this;
  }

  var _proto = ErrorBoundary.prototype;

  _proto.componentDidCatch = function componentDidCatch(error, info) {
    if (_config.onError) {
      try {
        var handled;

        if (this.props.onError) {
          handled = this.props.onError(error, info);
        }

        if (!handled) {
          _config.onError(error, info);
        }
      } catch (ignoredError) {
        console.log(ignoredError);
      }
    }

    this.setState({
      error: error
    });
  };

  _proto.render = function render() {
    var children = this.props.children;
    var error = this.state.error;

    if (error !== null) {
      debugger;
      return null;
    }

    return children || null;
  };

  return ErrorBoundary;
}(Component);

function MemoFnComponent(Component, onError) {
  onError = onError || _config.onError;
  var out = Component;

  if (onError) {
    out = function out(props) {
      return React.createElement(ErrorBoundary, null, createElement(Component, Object.assign({
        onError: onError
      }, props)));
    };
  }

  return memo(out);
}
function MemoFnComponentWithRef(Component, onError) {
  var out = Component;

  if (onError || _config.onError) {
    var Wrapped = function Wrapped(props, ref) {
      return React.createElement(ErrorBoundary, null, createElement(Component, Object.assign({
        onError: onError,
        ref: ref
      }, props)));
    };

    out = forwardRef(Wrapped);
  }

  return memo(out);
}

var _window;

// @ts-ignore
var ResizeObserver = typeof window !== 'undefined' && ((_window = window) == null ? void 0 : _window.ResizeObserver);

var polyfillResizeObserver = function polyfillResizeObserver(resizeObserver) {
  var _window2;

  // @ts-ignore
  ResizeObserver = ((_window2 = window) == null ? void 0 : _window2.ResizeObserver) || resizeObserver;
};

var timeouts = {};
function hasTimeoutOnce(name) {
  return !!timeouts[name];
}
function timeoutOnce(name, cb, time) {
  for (var _len = arguments.length, args = new Array(_len > 3 ? _len - 3 : 0), _key = 3; _key < _len; _key++) {
    args[_key - 3] = arguments[_key];
  }

  var t = timeouts[name];

  if (t) {
    clearTimeout(t);
  }

  timeouts[name] = setTimeout(function () {
    delete timeouts[name];
    cb.apply(void 0, args);
  }, time);
}
function clearTimeoutOnce(name) {
  var t = timeouts[name];

  if (t) {
    clearTimeout(t);
    delete timeouts[name];
  }
}

var useEverHadValue = function useEverHadValue(value, targetValue) {
  var ref = useRef(false);
  ref.current = ref.current || value === targetValue;
  return ref.current;
};

function useForceRender() {
  var _useReducer = useReducer(function (s) {
    return s + 1;
  }, 0),
      forceRender = _useReducer[1];

  return forceRender;
}

function useMakeRef(value) {
  var ref = useRef();
  ref.current = value;
  return ref;
}

function usePrevious(value) {
  var ref = useRef();
  var ret = ref.current;
  ref.current = value;
  return ret;
}

function useStateWithRef(initialValue) {
  var _useState = useState(initialValue),
      value = _useState[0],
      setValue = _useState[1];

  var ref = useRef(value); // Set wraps around useState's set and saves to ref

  var set = useCallback(function (v) {
    if (isFunction(v)) {
      v = v(ref.current);
    }

    ref.current = v;
    setValue(v);
  }, []);
  return [value, set, ref];
}

function useInterval(cb, ms) {
  useEffect(function () {
    var _int = setInterval(function () {
      cb();
    }, ms);

    return function () {
      return clearInterval(_int);
    };
  }, [ms, cb]);
}

function getSize(el) {
  return el ? {
    width: el.offsetWidth,
    height: el.offsetHeight
  } : {
    width: 0,
    height: 0
  };
}

var useComponentSize = function useComponentSize(ref) {
  var refSize = useRef({
    width: 0,
    height: 0
  });
  var fr = useForceRender();
  var handleResize = useCallback(function () {
    if (ref.current) {
      var oldSize = refSize.current;
      var newSize = getSize(ref.current);

      if (newSize && (newSize.width !== oldSize.width || newSize.height !== oldSize.height)) {
        refSize.current = newSize;
        fr();
      }
    }
  }, [ref, fr]); // @ts-ignore

  useLayoutEffect(function () {
    var el = ref.current;

    if (el) {
      handleResize();
      var resizeObserver = new ResizeObserver(handleResize);
      resizeObserver.observe(el);
      return function () {
        resizeObserver.disconnect();
        resizeObserver = undefined;
      };
    }
  }, [ref.current]); // eslint-disable-line react-hooks/exhaustive-deps

  return refSize.current;
};
var useComponentSizeChange = function useComponentSizeChange(ref, cb) {
  var refSize = useRef({
    width: 0,
    height: 0
  });
  var handleResize = useCallback(function () {
    if (ref.current) {
      var oldSize = refSize.current;
      var newSize = getSize(ref.current);

      if (newSize && (newSize.width !== oldSize.width || newSize.height !== oldSize.height)) {
        refSize.current = newSize;
        cb == null ? void 0 : cb(newSize);
      }
    }
  }, [ref, cb]); // @ts-ignore

  useEffect(function () {
    var el = ref.current;

    if (el) {
      handleResize();
      var resizeObserver = new ResizeObserver(handleResize);
      resizeObserver.observe(el);
      return function () {
        resizeObserver.disconnect();
        resizeObserver = undefined;
      };
    }
  }, [ref.current]); // eslint-disable-line react-hooks/exhaustive-deps

  return refSize.current;
};

export { ConfigureMemoFnComponent, MemoFnComponent, MemoFnComponentWithRef, ResizeObserver, animationFrameOnce, arrayInsertSorted, arrayRemove, arrayRemoveAt, clearAnimationFrameOnce, clearTimeoutOnce, hasAnimationFrameOnce, hasTimeoutOnce, isArray, isBoolean, isFunction, isNumber, isObject, isString, polyfillResizeObserver, timeoutOnce, useComponentSize, useComponentSizeChange, useEverHadValue, useForceRender, useInterval, useMakeRef, usePrevious, useStateWithRef };
//# sourceMappingURL=tools.esm.js.map
